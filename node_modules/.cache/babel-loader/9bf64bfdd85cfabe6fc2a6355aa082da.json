{"ast":null,"code":"import { ethers } from 'ethers';\nimport TOKEN_ABI from '../abis/Token.json';\nimport EXCHANGE_ABI from '../abis/Exchange.json';\nexport const loadProvider = dispatch => {\n  const connection = new ethers.providers.Web3Provider(window.ethereum);\n  dispatch({\n    type: 'PROVIDER_LOADED',\n    connection\n  });\n  return connection;\n};\nexport const loadNetwork = async (provider, dispatch) => {\n  const {\n    chainId\n  } = await provider.getNetwork();\n  dispatch({\n    type: 'NETWORK_LOADED',\n    chainId\n  });\n  return chainId;\n};\nexport const loadAccount = async (provider, dispatch) => {\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts'\n  });\n  const account = ethers.utils.getAddress(accounts[0]);\n  dispatch({\n    type: 'ACCOUNT_LOADED',\n    account\n  });\n  let balance = await provider.getBalance(account);\n  balance = ethers.utils.formatEther(balance);\n  dispatch({\n    type: 'ETHER_BALANCE_LOADED',\n    balance\n  });\n  return account;\n};\nexport const loadTokens = async (provider, addresses, dispatch) => {\n  let token, symbol;\n  token = new ethers.Contract(addresses[0], TOKEN_ABI, provider);\n  symbol = await token.symbol();\n  dispatch({\n    type: 'TOKEN_1_LOADED',\n    token,\n    symbol\n  });\n  token = new ethers.Contract(addresses[1], TOKEN_ABI, provider);\n  symbol = await token.symbol();\n  dispatch({\n    type: 'TOKEN_2_LOADED',\n    token,\n    symbol\n  });\n  return token;\n};\nexport const loadExchange = async (provider, address, dispatch) => {\n  const exchange = new ethers.Contract(address, EXCHANGE_ABI, provider);\n  dispatch({\n    type: 'EXCHANGE_LOADED',\n    exchange\n  });\n  return exchange;\n};\nexport const subscribeToEvents = (exchange, dispatch) => {\n  exchange.on('Deposit', (token, user, amount, balance, event) => {\n    dispatch({\n      type: 'TRANSFER_SUCCESS',\n      event\n    });\n  });\n  exchange.on('Withdraw', (token, user, amount, balance, event) => {\n    dispatch({\n      type: 'TRANSFER_SUCCESS',\n      event\n    });\n  });\n}; // ------------------------------------------------------------------------------\n// LOAD USER BALANCES (WALLET & EXCHANGE BALANCES)\n\nexport const loadBalances = async (exchange, tokens, account, dispatch) => {\n  let balance = ethers.utils.formatUnits(await tokens[0].balanceOf(account), 18);\n  dispatch({\n    type: 'TOKEN_1_BALANCE_LOADED',\n    balance\n  });\n  balance = ethers.utils.formatUnits(await exchange.balanceOf(tokens[0].address, account), 18);\n  dispatch({\n    type: 'EXCHANGE_TOKEN_1_BALANCE_LOADED',\n    balance\n  });\n  balance = ethers.utils.formatUnits(await tokens[1].balanceOf(account), 18);\n  dispatch({\n    type: 'TOKEN_2_BALANCE_LOADED',\n    balance\n  });\n  balance = ethers.utils.formatUnits(await exchange.balanceOf(tokens[1].address, account), 18);\n  dispatch({\n    type: 'EXCHANGE_TOKEN_2_BALANCE_LOADED',\n    balance\n  });\n}; // ------------------------------------------------------------------------------\n// TRANSFER TOKENS (DEPOSIT & WITHDRAWS)\n\nexport const transferTokens = async (provider, exchange, transferType, token, amount, dispatch) => {\n  let transaction;\n  dispatch({\n    type: 'TRANSFER_REQUEST'\n  });\n\n  try {\n    const signer = await provider.getSigner();\n    const amountToTransfer = ethers.utils.parseUnits(amount.toString(), 18);\n\n    if (transferType === 'Deposit') {\n      transaction = await token.connect(signer).approve(exchange.address, amountToTransfer);\n      await transaction.wait();\n      transaction = await exchange.connect(signer).depositToken(token.address, amountToTransfer);\n    } else {\n      transaction = await exchange.connect(signer).withdrawToken(token.address, amountToTransfer);\n    }\n\n    await transaction.wait();\n  } catch (error) {\n    dispatch({\n      type: 'TRANSFER_FAIL'\n    });\n  }\n};","map":{"version":3,"sources":["/Users/sam4130/Documents/Blockchain/BLCP-ui-redux-setup/src/store/interactions.js"],"names":["ethers","TOKEN_ABI","EXCHANGE_ABI","loadProvider","dispatch","connection","providers","Web3Provider","window","ethereum","type","loadNetwork","provider","chainId","getNetwork","loadAccount","accounts","request","method","account","utils","getAddress","balance","getBalance","formatEther","loadTokens","addresses","token","symbol","Contract","loadExchange","address","exchange","subscribeToEvents","on","user","amount","event","loadBalances","tokens","formatUnits","balanceOf","transferTokens","transferType","transaction","signer","getSigner","amountToTransfer","parseUnits","toString","connect","approve","wait","depositToken","withdrawToken","error"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers'\nimport TOKEN_ABI from '../abis/Token.json';\nimport EXCHANGE_ABI from '../abis/Exchange.json';\n\nexport const loadProvider = (dispatch) => {\n  const connection = new ethers.providers.Web3Provider(window.ethereum)\n  dispatch({ type: 'PROVIDER_LOADED', connection })\n\n  return connection\n}\n\nexport const loadNetwork = async (provider, dispatch) => {\n  const { chainId } = await provider.getNetwork()\n  dispatch({ type: 'NETWORK_LOADED', chainId })\n\n  return chainId\n}\n\nexport const loadAccount = async (provider, dispatch) => {\n  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n  const account = ethers.utils.getAddress(accounts[0])\n\n  dispatch({ type: 'ACCOUNT_LOADED', account })\n\n  let balance = await provider.getBalance(account)\n  balance = ethers.utils.formatEther(balance)\n\n  dispatch({ type: 'ETHER_BALANCE_LOADED', balance })\n\n  return account\n}\n\nexport const loadTokens = async (provider, addresses, dispatch) => {\n  let token, symbol\n\n  token = new ethers.Contract(addresses[0], TOKEN_ABI, provider)\n  symbol = await token.symbol()\n  dispatch({ type: 'TOKEN_1_LOADED', token, symbol })\n\n  token = new ethers.Contract(addresses[1], TOKEN_ABI, provider)\n  symbol = await token.symbol()\n  dispatch({ type: 'TOKEN_2_LOADED', token, symbol })\n\n  return token\n}\n\nexport const loadExchange = async (provider, address, dispatch) => {\n  const exchange = new ethers.Contract(address, EXCHANGE_ABI, provider);\n  dispatch({ type: 'EXCHANGE_LOADED', exchange })\n\n  return exchange\n}\n\nexport const subscribeToEvents = (exchange, dispatch) => {\n  exchange.on('Deposit', (token, user, amount, balance, event) => {\n    dispatch({ type: 'TRANSFER_SUCCESS', event })\n  })\n\n  exchange.on('Withdraw', (token, user, amount, balance, event) => {\n    dispatch({ type: 'TRANSFER_SUCCESS', event })\n  })\n}\n\n// ------------------------------------------------------------------------------\n// LOAD USER BALANCES (WALLET & EXCHANGE BALANCES)\n\n\nexport const loadBalances = async (exchange, tokens, account, dispatch) => {\n  let balance = ethers.utils.formatUnits(await tokens[0].balanceOf(account), 18)\n  dispatch({ type: 'TOKEN_1_BALANCE_LOADED', balance })\n\n  balance = ethers.utils.formatUnits(await exchange.balanceOf(tokens[0].address, account), 18)\n  dispatch({ type: 'EXCHANGE_TOKEN_1_BALANCE_LOADED', balance })\n\n  balance = ethers.utils.formatUnits(await tokens[1].balanceOf(account), 18)\n  dispatch({ type: 'TOKEN_2_BALANCE_LOADED', balance })\n\n  balance = ethers.utils.formatUnits(await exchange.balanceOf(tokens[1].address, account), 18)\n  dispatch({ type: 'EXCHANGE_TOKEN_2_BALANCE_LOADED', balance })\n\n}\n\n// ------------------------------------------------------------------------------\n// TRANSFER TOKENS (DEPOSIT & WITHDRAWS)\n\nexport const transferTokens =  async (provider, exchange, transferType, token, amount, dispatch) => {\n  let transaction\n\n  dispatch({ type: 'TRANSFER_REQUEST' })\n\n  try {\n    const signer = await provider.getSigner()\n    const amountToTransfer = ethers.utils.parseUnits(amount.toString(), 18)\n\n    if (transferType === 'Deposit') {\n      transaction = await token.connect(signer).approve(exchange.address, amountToTransfer)\n      await transaction.wait()\n      transaction = await exchange.connect(signer).depositToken(token.address, amountToTransfer)\n    } else {\n      transaction = await exchange.connect(signer).withdrawToken(token.address, amountToTransfer)\n    }\n\n    await transaction.wait()\n\n  } catch(error) {\n    dispatch({ type: 'TRANSFER_FAIL' })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}